### 나무자르기 [백준](https://www.acmicpc.net/blog/view/109) 설명
```cpp
#include <iostream>
#include <algorithm>
using namespace std;

int n, m, height[1'000'001]; // 나무의수, 가져갈길이, 나무의높이들

// 결정 문제: mid 높이에 절단기를 위치했을 때 m 길이 이상의 나무를 얻을 수 있는가?
bool check(const int mid) { 
	long long sum = 0; // 오버플로우 조심
	for (int i = 0; i < n; i++) {
		if (height[i] > mid) sum += (height[i] - mid);
	}
	return sum >= m;
}

int main() {
	cin >> n >> m;
	for (int i = 0; i < n; i++) cin >> height[i];

	// 1. Check(st) = T, Check(en) = F를 만족하는가?
	// 2. st는 정답이 될 수 있는 모든 범위를 나타낼 수 있는가? (정답은 0 ~ max(v) - 1라 가능)
	int st = 0, en = 1e9; // [st, en]가 Check(st) != Check(en)가 되도록 구간 설정

	while (st + 1 < en) { //1. st와 en 사이에 다른 칸이 존재하는가?
		int mid = st/2 + en/2 + (1&st&en); // 항상 st < mid < en를 만족 (평균을 생각해보면 o)
		if (check(mid)) st = mid; // 어떤 조건 check(mid)를 만족하는 x의 최댓값 또는 최솟값 찾기
		else en = mid;
	}
	cout << st;
	return 0;
}
```

<br>

### 종현오빠처럼 풀기
```cpp
inline long long woodSum(const int mid) {
	long long sum = 0;
	for (int h : height) if (h > mid) sum += (h-mid);
	return sum;
} // 원래 없을 수도

int check() { // 원래 bool
	int st = 0, en = 1e9; // 범위
	int ans = 0;

	while (st <= en) {
		int mid = st/2 + en/2 + (1&st&en); // (st+en)/2
        
		if (woodSum(mid) >= M) { // 성공조건
			ans = mid;
			st = mid + 1; // st랑 en이 바뀔 수는 있어
		}
		else en = mid - 1;
	}
	return ans;
}

int main() {
	cin >> N >> M;
	for (int i = 0; i < N; i++) cin >> height[i];
	cout << check();
	return 0;
}
```

<br>

### 랜선자르기 풀기